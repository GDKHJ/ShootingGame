오브젝트 풀(Object Pool)

C#, JAVA 등의 언어에서는 VM(가상 머신)을
제공하고 GC(가비지 컬렉터)라는 기능이
존재합니다.

제거하는 과정에서 '호출되는
소프트웨어'라고 생각하시면 됩니다.

CPU를 활용해서 작동하기 때문에
게임을 돌리면서 GC 호출로 인해
CPU가 낭비되는 상황이 발생할 수 있습니다.

왠만하면 GC의 호출을 최소화하는 작업이
필요합니다.(의도된 것이 아니라면)

따라서 사용자는 사용할 데이터를
미리 메모리에 모두 올리고 메모리의
삭제를 진행하지 않습니다.

1. 생성은 1번(시작 시, 상황에 따라)
2. 사용이 끝난 값은 비활성화 처리
3. 이 과정에서 생성물을 따로 보관해주는 곳을
   만든다(Pool)

예시) 슈팅 게임의 탄창 시스템
  1. 탄창을 준비합니다.(탄창 안에는 총알이 존재)
  2. 탄창에 넣을 총알 개수만큼 반복적으로 생성합니다.
  3. 탄창의 총알을 소모할 때마다, 비활성화로 전환

예시)    몬스터 생성 풀
  1. 몬스터 풀을 준비합니다.(풀 안에는 몬스터가 존재)
  2. 특정 수만큼 생성을 반복합니다. 1회
  3. 생성 후 전체 비활성화
  4. 생성 시간을 체크해 풀에서 몬스터를 활성화합니다.

구현 : 인터페이스 활용(풀을 여러 형태로 만들 경우)
         -> 풀에 대한 접근 값
         -> 풀에서의 생성
         -> 풀로 반납

        특정 클래스에 오브젝트 풀 직접 구현
======================================        
Script execution Order
유니티 프로젝트 내에서 스크립트의 실행
순서를 조절할 수 있습니다.

코드를 짜다보면 유니티 라이프 싸이클
함수 단위로 작업을 진행하면서
실행 타이밍이 안맞아서 제대로
적용이 안되는 경우

ex) 오브젝트 생성
     생성된 오브젝트에 기능 추가
    라고할 때 타이밍 문제

이 경우라면
타이밍 순서 변경(awake -> exit)의 구간
코드 작성 변경으로 해결이 가능

또는 스크립트 실행 순서 변경을 프로젝트
내에서 설정해서 처리합니다.

음수가 높은 스크립트를 기준으로
실행합니다.

+ 버튼을 눌러 스크립트를 연결해서
 상황에 맞게 배치한다.








































